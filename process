#!/usr/bin/env python3
import argparse
import datetime
import operator
import os.path
import sys
from typing import Any, Dict, Iterator, List, Optional, Tuple

import docutils.core
import ibis
import ibis.errors
import ibis.filters
import ibis.loaders
import ibis.nodes
import yaml


@ibis.filters.register('dformat')
def delta_formatter(delta: datetime.timedelta, delta_format: str='hh:mm') -> str:
    if isinstance(delta, ibis.errors.Undefined):
        return ''
    if delta_format == "decimal":
        return delta_to_decimal(delta)
    elif delta_format == "hh:mm":
        return delta_to_hhmm(delta)
    elif delta_format == "text":
        return delta_to_text(delta)
    else:
        assert False


@ibis.filters.register('rst')
def rst_formatter(text: str) -> str:
    if text is None:
        return ""
    return docutils.core.publish_parts(text, writer_name='html')['html_body']


@ibis.nodes.register('rst_l1_header', 'end_rst_l1_header')
class RstL1Header(ibis.nodes.Node):
    def render(self, context: Any) -> str:
        content = super().render(context).replace('\n', '')
        result = [
            "="*len(content),
            content,
            "="*len(content),
        ]
        return "\n".join(result)


@ibis.nodes.register('rst_l2_header', 'end_rst_l2_header')
class RstL2Header(ibis.nodes.Node):
    def render(self, context: Any) -> str:
        content = super().render(context).replace('\n', '')
        result = [
            content,
            "-"*len(content),
        ]
        return "\n".join(result)


@ibis.nodes.register('rst_l3_header', 'end_rst_l3_header')
class RstL3Header(ibis.nodes.Node):
    def render(self, context: Any) -> str:
        content = super().render(context).replace('\n', '')
        result = [
            content,
            "~"*len(content),
        ]
        return "\n".join(result)


def parse_date(string: str) -> datetime.date:
    yyyy, mm, dd = string.split("-", maxsplit=3)
    return datetime.date(year=int(yyyy), month=int(mm), day=int(dd))


def parse_time(string: str) -> datetime.time:
    hh, mm = string.split(":", maxsplit=2)
    return datetime.time(hour=int(hh), minute=int(mm))


def parse_datetime(string: str) -> datetime.datetime:
    date_str, time_str = string.split(" ", maxsplit=2)
    date = parse_date(date_str)
    time = parse_time(time_str)
    return datetime.datetime.combine(date, time)


def parse_delta(string: str) -> datetime.timedelta:
    hh, mm = string.split(":", maxsplit=2)
    return datetime.timedelta(hours=int(hh), minutes=int(mm))


def delta_to_decimal(delta: datetime.timedelta) -> str:
    days = delta.days
    return str(round(days * 24 + delta.seconds / 3600, 1))


def delta_to_hhmm(delta: datetime.timedelta) -> str:
    days = delta.days
    negative = "+"
    if days < 0:
        delta = -delta
        days = delta.days
        negative = "-"
    value, seconds = divmod(delta.seconds, 60)
    hours, minutes = divmod(value, 60)

    hh = hours + days*24
    mm = minutes
    return "%s%02d:%02d" % (negative, hh, mm)


def delta_to_text(delta: datetime.timedelta) -> str:
    days = delta.days
    negative = ""
    if days < 0:
        delta = -delta
        days = delta.days
        negative = "-"
    value, seconds = divmod(delta.seconds, 60)
    hours, minutes = divmod(value, 60)

    hh = hours + days*24
    mm = minutes

    result = []

    if hh == 1:
        result.append("%d hour" % hh)
    elif hh > 1:
        result.append("%d hours" % hh)

    if mm == 1:
        result.append("%d minute" % mm)
    if mm > 0:
        result.append("%d minutes" % mm)

    return negative + " and ".join(result)


def delta_to_format(delta: datetime.timedelta, delta_format: str) -> str:
    if delta_format == "decimal":
        return delta_to_decimal(delta)
    elif delta_format == "hh:mm":
        return delta_to_hhmm(delta)
    else:
        assert False


DateRange = Tuple[Optional[datetime.date], Optional[datetime.date]]


def get_date_range(date: datetime.date, one: bool, two: bool, month: bool) -> DateRange:
    current_date = datetime.datetime.combine(date, datetime.time())

    start_range: Optional[datetime.datetime] = None
    stop_range: Optional[datetime.datetime] = None
    if one:
        start_range = (
            current_date
            - datetime.timedelta(days=current_date.weekday())
        )
        stop_range = (
            current_date
            - datetime.timedelta(days=current_date.weekday())
            + datetime.timedelta(days=6)
        )
    elif two:
        start_range = (
            current_date
            - datetime.timedelta(days=current_date.weekday())
            - datetime.timedelta(days=7)
        )
        stop_range = (
            current_date
            - datetime.timedelta(days=current_date.weekday())
            + datetime.timedelta(days=6)
        )
    elif month:
        start_range = current_date.replace(day=1)
        stop_range = (
            current_date.replace(month=current_date.month+1, day=1)
            - datetime.timedelta(days=1)
        )

    start_date: Optional[datetime.date] = None
    if start_range is not None:
        start_date = start_range.date()

    stop_date: Optional[datetime.date] = None
    if stop_range is not None:
        stop_date = stop_range.date()

    return (start_date, stop_date)


def round_timedelta(td: datetime.timedelta, period: datetime.timedelta) -> datetime.timedelta:
    """
    Rounds the given timedelta by the given timedelta period
    :param td: `timedelta` to round
    :param period: `timedelta` period to round by.
    """
    period_seconds = period.total_seconds()
    half_period_seconds = period_seconds / 2
    remainder = td.total_seconds() % period_seconds
    if remainder >= half_period_seconds:
        return datetime.timedelta(
            seconds=td.total_seconds() + (period_seconds - remainder))
    else:
        return datetime.timedelta(
            seconds=td.total_seconds() - remainder)


class Entry:
    def __init__(
            self, *,
            project: 'Project',
            date: datetime.date, title: str, text: str,
            start_time: datetime.time, stop_time: datetime.time,
            break_delta: datetime.timedelta, t_raw_delta: datetime.timedelta,
            round_delta: datetime.timedelta, total_delta: datetime.timedelta) -> None:
        self.project = project
        self.date = date
        self.title = title
        self.text = text
        self.start_time = start_time
        self.stop_time = stop_time
        self.break_delta = break_delta
        self.t_raw_delta = t_raw_delta
        self.round_delta = round_delta
        self.total_delta = total_delta


class AggregatedTextEntry:
    def __init__(
            self, *,
            title: str, text: str,
            total_delta: datetime.timedelta) -> None:
        self.title = title
        self.text = text
        self.total_delta = total_delta


class AggregatedDay:
    def __init__(
            self, *, date: datetime.date,
            total_delta: datetime.timedelta) -> None:
        self.date = date
        self.total_delta = total_delta


class EntryList:
    def __init__(self) -> None:
        self._dates: List[datetime.date] = []
        self._entries: Dict[datetime.date, List[Entry]] = {}
        self.t_raw_delta = datetime.timedelta()
        self.total_delta = datetime.timedelta()
        self.round_delta = datetime.timedelta()

    def add_entry(self, entry: Entry) -> None:
        if entry.date not in self._entries:
            self._entries[entry.date] = []
            self._dates.append(entry.date)
        self._entries[entry.date].append(entry)

        self.t_raw_delta += entry.t_raw_delta
        self.total_delta += entry.total_delta
        self.round_delta = self.total_delta - self.t_raw_delta

        self._resort()

    def _resort(self) -> None:
        self._dates.sort()
        for date in self._dates:
            self._entries[date].sort(key=operator.attrgetter('start_time'))

    @property
    def is_empty(self) -> bool:
        return len(self._entries) == 0

    @property
    def sequential(self) -> Iterator[Entry]:
        for date in self._dates:
            for entry in self._entries[date]:
                yield entry

    def daily_report(self) -> Iterator[AggregatedDay]:
        days: Dict[datetime.date, Dict[str, datetime.timedelta]] = {}

        for date in self._dates:
            for entry in self._entries[date]:
                if date not in days:
                    days[date] = {
                        'total_delta': datetime.timedelta()
                    }
                days[date]['total_delta'] += entry.total_delta

        dates = list(days.keys())
        dates.sort()
        for date in dates:
            yield AggregatedDay(
                date=date,
                total_delta=days[date]['total_delta']
            )

    def aggregated_text_report(self) -> Iterator[AggregatedTextEntry]:
        report: Dict[str, str] = {}
        delta: Dict[str, datetime.timedelta] = {}
        for date in self._dates:
            for entry in self._entries[date]:
                if entry.title not in report:
                    report[entry.title] = ""
                    delta[entry.title] = datetime.timedelta()
                if entry.text is not None:
                    report[entry.title] += entry.text
                delta[entry.title] += entry.total_delta

        titles = list(report.keys())
        titles.sort()
        for title in titles:
            yield AggregatedTextEntry(
                title=title,
                text=report[title],
                total_delta=delta[title],
            )


class Project(EntryList):
    def __init__(self, filename: str, name: str) -> None:
        self.filename = filename
        self.name = name
        self.entries: List[Entry] = []
        super().__init__()


class Entries:
    def __init__(self, *, date_range: DateRange, files: List[str]) -> None:
        self._date_range = date_range
        self._files = files
        self._dates: List[datetime.date] = []
        # self.t_raw_delta = datetime.timedelta()
        # self.total_delta = datetime.timedelta()
        # self._entries: Dict[datetime.date, List[Entry]] = {}
        # self._projects: List[Project] = []
        self.all = EntryList()
        self._projects: List[Project] = []
        self._read()

    def _read(self) -> None:
        current_datetime = datetime.datetime.now()
        current_date = current_datetime.date()
        start_range = self._date_range[0]
        stop_range = self._date_range[1]

        self.start_date = start_range
        self.stop_date = stop_range

        self._projects = []
        for filename in self._files:
            with open(filename) as stream:
                root = yaml.safe_load(stream)

            project_name = root["project"]
            period = parse_delta(root["period"])

            project = Project(
                filename=filename,
                name=project_name,
            )

            self._projects.append(project)

            for date in root["dates"].keys():
                entries = root["dates"][date]
                if start_range and date < start_range:
                    continue
                if stop_range and date > stop_range:
                    continue
                for entry in entries:
                    entry_start_t = parse_time(entry['start'])
                    if 'stop' not in entry and date == current_date:
                        entry_stop_t = current_datetime.time()
                    else:
                        entry_stop_t = parse_time(entry['stop'])
                    if 'break' in entry:
                        entry_break = parse_delta(entry['break'])
                    else:
                        entry_break = datetime.timedelta()

                    entry_start_dt = datetime.datetime.combine(date, entry_start_t)
                    entry_stop_dt = datetime.datetime.combine(date, entry_stop_t)

                    assert entry_stop_dt > entry_start_dt
                    if entry.get('future', False):
                        if entry_start_dt < current_datetime:
                            raise RuntimeError('%s: Future entry starts in the past' % filename)
                    else:
                        if entry_start_dt > current_datetime:
                            raise RuntimeError('%s: Entry starts in the future' % filename)
                        if entry_stop_dt > current_datetime and date != current_date:
                            raise RuntimeError('%s: Entry stops in the future' % filename)

                    entry_t_raw_delta = entry_stop_dt - entry_start_dt - entry_break
                    entry_total_delta = round_timedelta(entry_t_raw_delta, period)
                    entry_round_delta = entry_total_delta - entry_t_raw_delta

                    entry = Entry(
                        project=project,
                        date=date,
                        title=entry['title'],
                        text=entry.get('text'),
                        start_time=entry_start_t,
                        stop_time=entry_stop_t,
                        break_delta=entry_break,
                        t_raw_delta=entry_t_raw_delta,
                        round_delta=entry_round_delta,
                        total_delta=entry_total_delta,
                    )

                    project.add_entry(entry)
                    self.all.add_entry(entry)

    @property
    def projects(self) -> Iterator[Project]:
        for project in self._projects:
            if not project.is_empty:
                yield project


def report(date_range: DateRange, files: List[str], template_name: str) -> None:
    home_dir = os.path.dirname(os.path.realpath(__file__))
    template_dir = os.path.join(home_dir, 'templates')
    loader = ibis.loaders.FileLoader(template_dir)
    template = loader(template_name)
    output = template.render({
        'entries': Entries(date_range=date_range, files=files),
    })
    sys.stdout.write(output)


def main() -> None:
    parser = argparse.ArgumentParser(description='Process time sheet.')
    parser.add_argument("-d", "--date", dest="date")

    group = parser.add_mutually_exclusive_group()
    group.add_argument("-1", "--1week", dest="one", action="store_true")
    group.add_argument("-2", "--2week", dest="two", action="store_true")
    group.add_argument("-m", "--month", dest="month", action="store_true")

    subparsers = parser.add_subparsers(dest='subparser')

    parser_a = subparsers.add_parser(
        'report', help="Generate complete report.")
    parser_a.add_argument("-t", "--template", dest="template_name", default="report.txt")
    parser_a.add_argument('files', nargs='+', help='Files to load.')

    kwargs = vars(parser.parse_args())

    d_string = kwargs.pop('date', None)
    if d_string is None:
        date = datetime.date.today()
    else:
        date = parse_date(d_string)

    date_range = get_date_range(
        date=date,
        one=kwargs.pop('one', None),
        two=kwargs.pop('two', None),
        month=kwargs.pop('month', None),
    )
    kwargs['date_range'] = date_range
    task = kwargs.pop('subparser', None)
    if task is not None:
        globals()[task](**kwargs)


if __name__ == "__main__":
    main()
